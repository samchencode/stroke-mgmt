<script>
  function notifyReactNative(messageType, content) {
    const message = {
      type: messageType,
      content,
    };
    window.ReactNativeWebView.postMessage(JSON.stringify(message));
  }
  const notifyLayout = notifyReactNative.bind(null, 'layout');
  const notifySwitchChanged = notifyReactNative.bind(null, 'switchchanged');
  const notifyError = notifyReactNative.bind(null, 'error');
  const notifyNextPressed = notifyReactNative.bind(null, 'nextpressed');
  const notifyLinkPressed = notifyReactNative.bind(null, 'linkpressed');

  ; // Report window height
  (function() {
    const notify = () => notifyLayout({
      width: document.body.offsetWidth,
      height: document.body.offsetHeight,
    });

    // Watch for opening of outcome dropdowns
    const bodyEl = document.querySelector('body')
    const observerCb = (mutationList) => {
      mutationList.forEach(mut => {
        if (mut.type !== 'attributes') return;
        if (mut.attributeName === 'open') notify();
      })
    }
    const observer = new MutationObserver(observerCb)
    observer.observe(bodyEl, {
      attributes: true,
      childList: true,
      subtree: true
    })

    // Wait for any images to finish loading
    window.onload = notify
    notify()
  })();

  ; // Listen to changes in switch values
  (function() {
    const inputs = Array.from(document.querySelectorAll('.template.switches__input'));
    for (const input of inputs) {
      input.addEventListener('change', ({
        target
      }) => {
        const id = target.dataset['switch-id'];
        const levelId = target.dataset['level-id'];
        notifySwitchChanged({
          id,
          levelId,
        });
      });
    }
  })();

  ; // Listen to click of next algorithm button
  (function() {
    const buttons = Array.from(document.querySelectorAll('.template.outcomes__button'));
    for (const button of buttons) {
      button.addEventListener('click', ({
        target
      }) => {
        const id = target.getAttribute('data-next-id');
        notifyNextPressed({
          id
        });
      });
    }
  })();

  ; // Listen to click of any link
  (function() {
    const links = Array.from(document.querySelectorAll('a[href]'))
    for (const a of links) {
      const href = a.getAttribute('href')
      if (href.slice(0, 1) === '#') continue
      a.addEventListener('click', (e) => {
        e.preventDefault()
        const href = e.target.getAttribute('href')
        notifyLinkPressed({
          href
        })
      })
    }
  })();

  ; // Report errors
  (function() {
    window.addEventListener('error', (e) =>
      notifyError({
        name: e.error.name,
        message: e.message,
      })
    );
  })();

  ; // Clear tooltip on click out
  (function() {
    const ignoreList = document.querySelectorAll('.template.switches__tooltip, .template.switches__group-label, .template.switches__tooltip-select')
    const selects = document.querySelectorAll('.template.switches__tooltip-select')

    document.body.addEventListener('click', (e) => {
      for (const el of selects) {
        el.checked = false
      }
    })
    Array.from(ignoreList).forEach(el => {
      el.addEventListener('click', (e) => e.stopPropagation())
    })
  })()
</script>